---
layout: post
title:  "buildbot源码解析"
author: lancelodliu
tags: [buildbot, test, ci]
---

# 从命令buildbot start master开始
## buildbot

buildbot命令实质是一个二进制，位于Python安装目录的`Scripts`目录下：

![](/imgs/2018-09-07-buildbot源码解析/0.png)

这个二进制可以用zip打开，里面是一个简单的`__main__.py`：

![](/imgs/2018-09-07-buildbot源码解析/1.png)

## `__main__.py`

![](/imgs/2018-09-07-buildbot源码解析/2.png)

这里是修改了一下命令行参数0，这个参数其实就是命令行输入的第一个命令，我们这里是`buildbot`。line 8的正则是去除了命令中的`-script.pyw`和`.exe`，随后进入到line 5的`run`中。

## buildbot.scripts.runner.run
这一部分的代码开始，建议使用pycharm等IDE打开`Lib\site-packages\buildbot`查看。

![](/imgs/2018-09-07-buildbot源码解析/3.png)

`run`的代码中处理了命令行参数，最终还是进入了`subcommandFunction`调用。这里的`config`是`Options`类，主要新增了`subCommands`属性：

![](/imgs/2018-09-07-buildbot源码解析/4.png)

关于这些项的定义则在其继承的`Options`基类（`Lib/site-packages/twisted/python/usage.py`）中：

![](/imgs/2018-09-07-buildbot源码解析/5.png)

我们关心的是start命令所做的事，所以进入`StartOptions`一探究竟（该类就定义在`runner.py`中）：

![](/imgs/2018-09-07-buildbot源码解析/6.png)

终于，这里出现了`subcommandFunction`。通过这个字符串以及反射方法`reflect.namedObject`，实际执行的是`buildbot.scripts.start`中的`start`方法，至此，也可以大致确定，buildbot的其他命令（stop/restart/create-master）也是用此实现方式。
### buildbot.scripts.start

![](/imgs/2018-09-07-buildbot源码解析/7.png)

start部分代码关注`lanchNoDaemon`、`launch`即可。
### lanchNoDaemon
就是阻塞调用`twistd.run()`

![](/imgs/2018-09-07-buildbot源码解析/8.png)

### launch
使用`reactor`调用`twistd.run()`，同时还写了个pid到文件。

![](/imgs/2018-09-07-buildbot源码解析/9.png)

## twisted.scripts
这里的`run`最后还是通过`WindowsApplicationRunner`（windows）的run方法进行调用：

![](/imgs/2018-09-07-buildbot源码解析/10.png)

### app.run
下图红框调用相当于调用上图第三个红框中的`_SomeApplicationRunner(config).run()`：

![](/imgs/2018-09-07-buildbot源码解析/11.png)

而`WindowsApplicationRunner`继承自`app.ApplicationRunner`，这就需要进入到`Lib/site-packages/twisted/application/app.py`：

![](/imgs/2018-09-07-buildbot源码解析/12.png)

光从构造函数看不出什么，看下`run`函数：

![](/imgs/2018-09-07-buildbot源码解析/13.png)

这里的`preApplication`和`postApplication`需要回到`WindowsApplicationRunner`，这个类位于`Lib/site-packages/twisted/scripts/_twistw.py`：

![](/imgs/2018-09-07-buildbot源码解析/14.png)

这里终于看到了核心，即`postApplication`，在这个函数中，注册了服务，启动了应用，最后启动了一个`Reactor`。

