---
layout: post
title:  "buildbot源码解析"
author: lancelodliu
---

# 从命令buildbot start master开始
## buildbot
buildbot命令实质是一个二进制，位于Python安装目录的Scripts目录下：

![](/imgs/2018-09-07-buildbot源码解析/0.png)

这个二进制可以用zip打开，里面是一个简单的__main__.py：
![](/imgs/2018-09-07-buildbot源码解析/1.png)
`__main__.py`内容为：
![](/imgs/2018-09-07-buildbot源码解析/2.png)
这里是修改了一下命令行参数0，这个参数其实就是命令行输入的第一个命令，我们这里是buildbot。line 8的正则是去除了命令中的-script.pyw和.exe，随后进入到line 5的run中。
buildbot.scripts.runner.run
这一部分的代码开始，建议使用pycharm等IDE打开Lib\site-packages\buildbot查看。

![](/imgs/2018-09-07-buildbot源码解析/3.png)
run的代码中处理了命令行参数，最终还是进入了subcommandFunction调用。这里的config是Options类，主要新增了subCommands属性：

![](/imgs/2018-09-07-buildbot源码解析/4.png)
关于这些项的定义则在其继承的Options基类（Lib/site-packages/twisted/python/usage.py）中：

![](/imgs/2018-09-07-buildbot源码解析/5.png)
我们关心的是start命令所做的事，所以进入StartOptions一探究竟（该类就定义在runner.py中）：

![](/imgs/2018-09-07-buildbot源码解析/6.png)
终于，这里出现了subcommandFunction。通过这个字符串以及反射方法reflect.namedObject，实际执行的是buildbot.scripts.start中的start方法，至此，也可以大致确定，buildbot的其他命令（stop/restart/create-master）也是用此实现方式。
buildbot.scripts.start

![](/imgs/2018-09-07-buildbot源码解析/7.png)
start部分代码关注lanchNoDaemon、launch即可。
lanchNoDaemon
就是阻塞调用twistd.run()

![](/imgs/2018-09-07-buildbot源码解析/8.png)
launch
使用reactor调用twistd.run()，同时还写了个pid到文件。

![](/imgs/2018-09-07-buildbot源码解析/9.png)

twisted.scripts
这里的run最后还是通过WindowsApplicationRunner（windows）的run方法进行调用：

![](/imgs/2018-09-07-buildbot源码解析/10.png)
app.run，下图红框调用相当于调用上图第三个红框中的_SomeApplicationRunner(config).run()：

![](/imgs/2018-09-07-buildbot源码解析/11.png)
而WindowsApplicationRunner继承自app.ApplicationRunner，这就需要进入到Lib/site-packages/twisted/application/app.py：

![](/imgs/2018-09-07-buildbot源码解析/12.png)
光从构造函数看不出什么，看下run函数：

![](/imgs/2018-09-07-buildbot源码解析/13.png)
这里的preApplication和postApplication需要回到WindowsApplicationRunner，这个类位于Lib/site-packages/twisted/scripts/_twistw.py：

![](/imgs/2018-09-07-buildbot源码解析/14.png)
这里终于看到了核心，即postApplication，在这个函数中，注册了服务，启动了应用，最后启动了一个Reactor。

