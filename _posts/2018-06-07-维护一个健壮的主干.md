---
layout: default
title:  "维护一个健壮的主干"
author: lancelodliu
tags: [test, ci]
---

# 健壮主干
健壮主干顾名思义，主干随时可用。不会一打开编辑器，弹出类似
>“All compiler errors have to be fixed before entering playmode”

的错误。

# 好处
好处显而易见，日常不用Code Review，开发不会阻塞，升职加薪走向人生巅峰。

# 动机
犯错在所难免，谁都会头脑发昏，漏提交、错提交、多了个句号、提交错了分支……
>提交前点一下run，看看有没有报错不就行了？

1. 培养团队良好的习惯不是一日之功
2. 业务爆炸时，习惯也要让步
3. 人无完人

# 如何实现？
机器不会犯错，让机器成为法官，用代码检测代码，公平、效率。整体上，运行流程如下：
1. 提交代码
2. 运行检查
3. 成功结束，失败回滚并等待修复
4. 提交修复

1,2,4都没有值得说明的地方，核心在于3的回滚操作。

## 关于回滚
回滚的本质是将一笔提交中的所有文件恢复到提交前的状态，从版本控制系统（VCS）的角度来看，这一笔提交就**如同没有存在过一样**。不同VCS有不同的操作实现，以Perforce为例，实现的方法是根据提交中的文件`Action`来进行**相反操作**：
* Add：删除
* Edit：取`提交的revision-1`
* Delete：增加

有了回滚，我们就有了让主干一直保持可用的可能。只要满足以下两个条件：
* 检查是持续不间断的
* 检查通过能够保证主干可用

那么任何一笔未能通过检查的提交都会被回滚。
理解了回滚的意义，剩下的重点就是：当回滚发生后，测试框架**如何处理后续的提交**。

## 0.1版本
在项目早期，我们是没有回滚的，失败了，测试框架就阻塞住，忽略后续的所有提交，直到评论中有`Fix xxxxxx`的提交到达，才会继续检查。
这个实现唯一的作用就是通知leader和提交者：主干坏了，赶紧来修吧。至于健壮的主干？不存在的，￣▽￣。

## 1.0版本
在忍受了0.1版本一段时间之后，bingxiaoliu提及了回滚的需求。在实现了回滚操作之后，1.0版本诞生了，它的特点是：
* 失败的提交会被回滚
* 失败之后测试框架会跳过后续提交，直到评论中有`Fix xxxxxx`的提交到达

1.0版本解决了主干不可用的问题，但由于跳过了后续提交的检查，形成了一个“检测盲区”。如果修复提交之前有大量的提交，且包含一个错误提交，测试框架的准确性就大幅劣化。

![盲区](/imgs/维护一个健壮的主干/0.png)

## 2.0版本
其实在回滚之后，主干就是好的了，那么为何要跳过修复前的提交呢？2.0版本呼之欲出：
* 失败的提交会被回滚
* 失败后，检查会继续

在2.0版本，测试框架需要支持的是记录出错提交。在对应的修复提交后，从记录中删除之，否则，需要不停地提醒出错的家伙：**你的提交被回滚了，请提交修复**。

NOTE：**无限提醒**是推荐的做法，因为无论邮件还是企业IM弹框，都存在漏看的可能。

## 2.1版本
2.0版本跑了没几天，问题再次出现。〒▽〒
Perforce的回滚操作实际由3部分组成：
1. 将文件恢复到上一个版本
2. 执行检查
3. 打包这些文件，提交

在1和3之间，我们需要对回滚后的结果进行再次检查，以确保主干完好，这形成了大概1~2分钟的过渡区。如果过渡区有新的提交，由于测试框架按照提交序号大小依次检查，毫无疑问这些提交都将基于回滚前的错误的codebase，产生误报。如下图：

![2.0版本的致命问题](/imgs/维护一个健壮的主干/1.png)

>上图中的`2`、`3`是必定失败的。以`2`为例，它是基于`1`的，因此针对`2`的回滚也是无效的，因为`2`的回滚即是`1`。

经过和mirabelsun讨论，我们敲定了最终的2.1版本：
1. 每次出现回滚时，记录回滚的提交序号，记录到一个数组中
2. 处理新提交时，先获取提交的文件，再检查其是否小于记录回滚的提交序号
  * 如果小于，按文件拉取满足条件的回滚提交

以上图2.0版本的问题为例，在检查`2`时，我们会拉取`4`的相关文件，确保`2`的检查基础是健壮的同时也确保了`2`的检查即使出错，也绝对和`1`无关。

### 2.1版本的隐患
2.1版本也不是尽善尽美，考虑一个特殊的情况，如下图：

![2.1隐患](/imgs/维护一个健壮的主干/2.png)

如果`1`和`2`有部分文件重叠：都涉及文件`a`。那么在检测`2`时，`a`实际使用的是回滚的`4`的版本，考虑到`4`是`1`的上一个版本`0`，最终使用的是`0`，即`a#1`，如果`2`依赖于`0`->`1`（或者说`a#1`->`a#2`）的一些改动，那么`2`必然是会失败的，在这种情况下，`2`会进入回滚流程，并且无法通过检查（因为1就失败了）从而阻塞测试框架。
这种特殊情况需要满足以下3个条件：
1. 在过渡区内提交（窗口期大约1~2分钟）
2. 两次提交有文件重叠
3. 依赖重叠文件的改动（而非文件相同部分）

我们认为这3个条件同时满足可能性较低，特别是条件2和3。这在按模块开发的游戏开发模式下几乎不太可能发生。最有可能触发2个条件的情况就是：开发小王提交完`1`之后，立刻发现了自己的错误，提交了`2`。即使如此，最坏的情况也不过是阻塞测试框架，使其退化为1.0版本。只要找上PM，狠狠地锤小王一顿，提交修复，恢复测试框架也就是了。O(∩_∩)O

# 参考
1. https://trunkbaseddevelopment.com/5-min-overview/
